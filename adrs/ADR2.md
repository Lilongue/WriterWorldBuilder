# ADR-002: Гибридная модель управления сущностями и их свойствами

**Статус:** Принято
**Дата:** 2025-09-29

## Контекст

В соответствии с [ADR-001](./ADR1.md), проект использует Local-First архитектуру с подходом "папка как сущность", где каждая сущность состоит из файлов `text.md` и `meta.yml`. Возникла необходимость определить механизм для создания различных **типов** сущностей (Персонаж, Локация и т.д.) с присущими им наборами полей (схемами), а также для управления связями между ними.

Первоначальная идея заключалась в использовании иерархии папок для неявного наследования свойств: сущность в папке `/Персонажи/Маги/` наследовала бы поля, определенные в `meta.yml` папок `/Персонажи/` и `/Персонажи/Маги/`. Однако анализ выявил ряд проблем с таким подходом, включая жесткую привязку к файловой структуре, сложности с рефакторингом и неспособность элегантно обрабатывать сложные случаи, такие как упорядоченные списки (главы) и отношения (семейные узы).

## Рассмотренные варианты

1. **Наследование на основе файловой системы:** Использование иерархии папок для определения типа и свойств сущности.
    * *Плюсы:* Интуитивно понятно для пользователя.
    * *Минусы:* Жесткость, сложность рефакторинга, невозможность множественного наследования (персонаж не может быть одновременно "королем" и "следопытом"), усложнение логики запросов.

2. **Система шаблонов (Архетипы):** Создание новых сущностей путем копирования предопределенной папки-шаблона.
    * *Плюсы:* Простота реализации.
    * *Минусы:* Отсутствие централизованного управления, что ведет к несогласованности данных в долгосрочной перспективе (изменение шаблона не влияет на уже созданные сущности).

3. **Гибридная модель (Явное типирование + UI-ориентированный подход):** Модель, сочетающая явное объявление типа в метаданных с умным пользовательским интерфейсом, который абстрагирует сложность хранения.

## Решение

Принята **Гибридная модель**. Она основана на следующих принципах:

1. **Явное типирование:** Тип сущности является ее основной характеристикой и в обязательном порядке указывается в поле `type` в ее файле `meta.yml`. Это поле является источником истины. Оно может поддерживать несколько типов (например, `type: [character, ranger]`).

2. **Централизованное определение схем (рекомендуется):** Схемы (наборы полей для каждого типа) должны определяться в выделенном месте (например, в папке `/.schemas/`). Это упрощает валидацию данных, рефакторинг и позволяет UI динамически строить формы редактирования.

3. **UI как основной интерфейс:** Пользователь взаимодействует с данными преимущественно через графический интерфейс приложения, а не напрямую с файловой системой. UI группирует сущности на основе их `type` (например, вкладки "Персонажи", "Локации" в боковой панели), а не их расположения на диске.

4. **Специализированные интерфейсы для сложных случаев:** UI предоставляет специализированные инструменты для работы со сложными типами данных, которые не укладываются в простую модель "объекта с полями":
    * **Упорядоченные структуры (Главы, Эпизоды):** Порядок дочерних элементов хранится в метаданных родителя (например, массив ID в `meta.yml` главы). UI отображает их в виде перетаскиваемого списка.
    * **Реляционные данные (Отношения):** Управляются через специальный интерфейс (например, вкладка "Отношения" на странице персонажа), который абстрагирует механизм хранения этих связей.

5. **Контекстно-зависимое создание:** При создании новой сущности UI может использовать ее будущее расположение в файловой системе как **подсказку** для предложения типа по умолчанию, упрощая рабочий процесс.

## Последствия

### Положительные

* **Гибкость:** Сущности не привязаны к своему местоположению. Поддерживаются множественные роли и типы.
* **Надежность:** Централизованное управление схемами делает рефакторинг и валидацию данных значительно проще и безопаснее.
* **Масштабируемость:** Архитектура способна обрабатывать сложные сценарии использования (повествование, хронологии, отношения), предоставляя для них адекватные инструменты.
* **Качественный UX:** Пользователь получает чистый, ориентированный на задачи интерфейс, который скрывает сложность файлового бэкенда.

### Отрицательные

* **Увеличение сложности реализации:** Требуется разработка более сложного UI/UX, включая динамические формы и специализированные редакторы. Бэкенд должен реализовать логику разрешения типов и схем.
* **Введение уровня абстракции:** Пользователю необходимо понимать концепцию "типов", хотя UI должен максимально направлять и упрощать этот процесс.
